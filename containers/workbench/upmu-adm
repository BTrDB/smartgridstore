#!/usr/bin/env python

import pymongo
import time
import os
import sys
import subprocess
import uuid
import shutil
import re
import bson.binary
import datetime
import readline

from configobj import ConfigObj

histfile = "/etc/sync/.upmu-adm-hist"
try:
    readline.read_history_file(histfile)
    # default history len is -1 (infinite), which may grow unruly
    readline.set_history_length(1000)
except IOError:
    pass
import atexit
atexit.register(readline.write_history_file, histfile)
del histfile

try:
  rows, columns = subprocess.check_output(['stty', 'size']).split()
  columns = int(columns)
  pad = (columns-28)/2
  if pad < 0:
    pad = 5
  if pad > 80:
    pad = 80
except:
  pad = 5

banner = """\n\033[97m\033[44m

{0}     _____  _____  _____   {0}
{0}    / ____|/ ____|/ ____|  {0}
{0}   | (___ | |  __| (___    {0}
{0}    \___ \| | |_ |\___ \   {0}
{0}    ____) | |__| |____) |  {0}
{0}   |_____/ \_____|_____/   {0}
{0}                           {0}
{0} Berkeley Smart Grid Store {0}
{0}      uPMU admin tool      {0}
\033[0m""".format(" "*pad)

print banner

dirty = False

def mknew(alias, serial, ext=False):
    rv = {"%alias":alias, "%active":True, "%serial_number":serial}
    rv["Metadata"] = {"SourceName":"uPMU", "Instrument":{"SerialNumber":serial}}
    tl = [(("L1ANG","L2ANG","L3ANG","C1ANG","C2ANG","C3ANG"),"Degrees"),
          (("L1MAG","L2MAG","L3MAG"), "Volts"),
          (("C1MAG","C2MAG","C3MAG"), "Amps"),
          (("LSTATE",), "bitmap")]
    if ext:
        tl += [(("FUND_W",), "Watts"),
               (("FUND_VA",), "unk"),
               (("FUND_VAR",), "unk"),
               (("FUND_DPF",), "unk"),
               (("FREQ_L1_1S",), "Hertz"),
               (("FREQ_L1_C37",), "Hertz")]
    for t in tl:
        unit = t[1]
        for subtag in t[0]:
            rv[subtag] = {"Path":"/upmu/"+alias+"/"+subtag,
                          "uuid":str(uuid.uuid4()).lower(),
                          "Properties":{"UnitofMeasure":unit}}
    return rv

autogenned = False

if not os.path.isfile("/etc/sync/admconfig.ini"):
  print "\033[91mWARN: \033[0muPMU-adm config file not found, generating default"
  with open("/etc/sync/admconfig.ini","w") as f:
    autogenned = True
    f.write("# autogenerated on %s\n" % time.ctime())
    f.write("# the path of the upmuconfig.ini file that will be adjusted\n")
    f.write("inifile = /etc/sync/upmuconfig.ini\n")
    f.write("# the mongoDB database\n")
    f.write("mongo = mongodb://mongo.local:27019\n")
    f.write("# the alias file for sync2q\n")
    f.write("alias = /etc/sync/serial_aliases.ini\n")

metaconfig = ConfigObj("/etc/sync/admconfig.ini")

if not os.path.isfile(metaconfig["inifile"]):
  print "\033[91mWARN: \033[0mCould not locate the upmuconfig.ini file, "
  if autogenned:
    print "  Not generating a blank one, because we just generated your main"
    print "  configuration. Please edit the admconfig.ini file to point to the "
    print "  correct upmuconfig.ini, or rerun upmu-admin to generate a blank one"
    sys.exit(0)
  else:
    print "\033[91mWARN: \033[0mGenerating a blank one"
    with open(metaconfig["inifile"], "w") as f:
      f.write("# autogenerated on %s\n" % time.ctime())

try:
  client = pymongo.MongoClient(metaconfig["mongo"])
  mdb = client.upmu_database
except:
  print "Could not establish a connection to mongoDB.",
  print "Please update the admconfig.ini file with the correct database details"
  sys.exit(1)

config = ConfigObj(metaconfig["inifile"])
origconfig = ConfigObj(metaconfig["inifile"])

def disp_help(tokens):
    """Show available commands"""
    print "The following commands are available:"
    for f in funcs.keys():
      print "\033[93m%s%s \033[0m%s" %(f," "*(10-len(str(f))), funcs[f].__doc__)

def create_funcs():
    help = disp_help

    def add(tokens):
      """Add a new uPMU to the system"""
      if len(tokens) not in  [4,5]:
        print "Usage: add ipaddr serial alias [ext]"
        return
      if len(tokens) == 4:
          ipaddr, serial, alias = tokens[1:]
          config[ipaddr] = mknew(alias, serial)
      else:
          ipaddr, serial, alias, ext = tokens[1:]
          config[ipaddr] = mknew(alias, serial, ext in ["true","1","True","TRUE"])
      global dirty
      dirty = True
      print "uPMU added, remember to type 'save' to persist configuration"

    def list(tokens):
      """List registered uPMUs"""
      if len(tokens) != 1:
        print "Usage: list"
        return
      print "      SERIAL   IP ADDRESS      EXT ALIAS"
      print "-"*columns
      pat = "%s %-8s %-15s %s %s"
      isext = lambda x : "T" if "FUND_W" in x else "F"
      for k in config:
        if k not in origconfig:
          prefx = "\033[92mNEW: \033[0m"
        else:
          prefx = "     "
        print pat % (prefx, config[k]["%serial_number"], k, isext(config[k]), config[k]["%alias"])
      for k in origconfig:
        if k not in config:
            prefx = "\033[91mDEL: \033[0m"
            print pat % (prefx, origconfig[k]["%serial_number"], k, isext(origconfig[k]), origconfig[k]["%alias"])

    def delbackup(tokens):
      """Delete specific backup files"""
      if len(tokens) < 3:
          print "Usage: delbackup serial year [month] [day] [hour]"
          return
      pattern = "/root/upmu_data/%04d" % int(tokens[2])
      if len(tokens) > 3:
          pattern += "/Month_%02d" % int(tokens[3])
      if len(tokens) > 4:
          pattern += "/Day_%02d" % int(tokens[4])
      if len(tokens) > 5:
          pattern += "/Hour_%02d" % int(tokens[5])
      ser = tokens[1]
      qry = {"name":{"$regex":pattern},"serial_number":ser}
      cnt = mdb.received_files.find(qry).count()

      if cnt == 0:
          print "No records found matching those criteria"
          return
      print "This will remove approximately %d records. Are you sure?" % cnt
      answer = raw_input("Type 'yes'> ")
      if answer != "yes":
          print "Aborting"
          return
      else:
          mdb.received_files.delete_many(qry)
          print "Done"

    def exportdat(tokens):
      """Export raw uPMU DAT files"""
      if len(tokens) < 4:
          print "Usage: exportdat directory serial year [month] [day] [hour]"
          return
      tgt = tokens[1]
      if not os.path.exists(tgt):
          os.mkdir(tgt)
      pattern = "/root/upmu_data/%04d" % int(tokens[3])
      if len(tokens) > 4:
          pattern += "/Month_%02d" % int(tokens[4])
      if len(tokens) > 5:
          pattern += "/Day_%02d" % int(tokens[5])
      if len(tokens) > 6:
          pattern += "/Hour_%02d" % int(tokens[6])
      ser = tokens[2]
      qry = {"name":{"$regex":pattern},"serial_number":ser}
      cur = mdb.received_files.find(qry)
      f = False
      for doc in cur:
          f = True
          suffix = doc["name"].split("/")[-1]
          fn = os.path.join(tgt, suffix)
          print "Saving: ", fn
          with open(fn,"w") as f:
              f.write(doc["data"])
      print "Export complete" if f else "No records found matching those criteria"

    def setext(tokens):
      """Set if extended dat files are emitted by this pmu"""
      if len(tokens) < 3:
          print "Usage: setext ipaddr true/false"
          return
      k = tokens[1]
      v = tokens[2] == "true"
      if k not in config:
          print "No PMU with that IP address"
          return
      alias = config[k]["%alias"]
      tl = [(("FUND_W",), "Watts"),
            (("FUND_VA",), "unk"),
            (("FUND_VAR",), "unk"),
            (("FUND_DPF",), "unk"),
            (("FREQ_L1_1S",), "Hertz"),
            (("FREQ_L1_C37",), "Hertz")]
      if v:
          if "FUND_W" in config[k]:
              print "PMU is already in extended mode"
              return
          del origconfig[k]
          for t in tl:
              unit = t[1]
              for subtag in t[0]:
                  config[k][subtag] = {"Path":"/upmu/"+alias+"/"+subtag,
                                "uuid":str(uuid.uuid4()).lower(),
                                "Properties":{"UnitofMeasure":unit}}
      else:
          if "FUND_W" not in config[k]:
              print "PMU is already out of extended mode"
              return
          del origconfig[k]
          for t in tl:
              for subtag in t[0]:
                  del config[k][subtag]
      global dirty
      dirty = True
      print "uPMU mondified, remember to type 'save' to persist configuration"

    def importdat(tokens):
      """Import raw uPMU DAT files"""
      if len(tokens) < 2:
          print "Usage: importdat directory"
          return
      #P3001276_2015-12-18-08-14-57.dat
      dlist = sorted(os.listdir(tokens[1]))
      for fname in dlist:
          pat = "^(P[0-9]{7})_(20[0-9]{2})-([01][0-9])-([0-9]{2})-([0-9]{2})-([0-9]{2})-([0-9]{2})\.dat$"
          g = re.match(pat, fname)
          if g is None:
              print "Skipping",fname," - does not match uPMU DAT filename format"
          else:
              with open(os.path.join(tokens[1],fname)) as f:
                  dat = f.read()
              gg = g.groups()
              serial = gg[0]
              year = int(gg[1])
              month = int(gg[2])
              day = int(gg[3])
              hour = int(gg[4])
              min = int(gg[5])
              sec = int(gg[6])
              doc = {
                "name": "/root/upmu_data/%04d/Month_%02d/Day_%02d/Hour_%02d/%s" %
                    (year, month, day, hour, fname),
                "published": False,
                "serial_number": serial,
                "time_received": datetime.datetime.utcnow(),
                "data": bson.binary.Binary(dat)
              }
              mdb.received_files.save(doc)
              print "Imported: ",fname

    def rem(tokens):
      """Deregister a uPMU"""
      if len(tokens) != 2:
        print "Usage: rem ip/serial/alias"
        return
      global dirty
      dirty = True
      rk = tokens[1]
      f = False
      if rk in config:
          f = True
          del config[rk]
      else:
          for k in config:
              if config[k]["%serial_number"] == rk:
                f = True
                del config[k]
                break
              if config[k]["%alias"] == rk:
                f = True
                del config[k]
                break
      print "uPMU deregistered" if f else "Not found"


    def save(tokens):
      """Save the configuration changes"""
      global origconfig, dirty
      shutil.copyfile(metaconfig["inifile"], ".inibackup."+str(int(time.time()*10)))
      config.write()
      dirty = False
      origconfig = ConfigObj(metaconfig["inifile"])
      with open(metaconfig["alias"],"w") as f:
          for k in config:
              f.write("%s=%s\n" %(config[k]["%serial_number"], config[k]["%alias"]))
      print "Wrote aliases to %s" % metaconfig["inifile"]
      print "Wrote metadata to %s" % metaconfig["alias"]

    def exit(tokens):
        """Exit (does not trigger a save)"""
        if len(tokens) != 1:
            print "Usage: exit"
            return
        if dirty:
            print "\nAbort - Not saving changes..."
        else:
            print "\nClean exit - no unsaved changes"
        raise SystemExit

    return locals()

funcs = create_funcs()

def exec_statement(string):
    tokens = string.split()
    if len(tokens) == 0:
        return

    command = tokens[0]
    if command not in funcs:
        exec_func = disp_help
        print "'{0}' is not a valid command".format(command)
    else:
        exec_func = funcs[command]

    exec_func(tokens)

while True:
    try:
        statement = raw_input("\033[94muPMU-adm\033[0m> ")
    except EOFError:
        if dirty:
            print "\nAbort - Not saving changes..."
        else:
            print "\nClean exit - no unsaved changes"
        raise SystemExit
    except KeyboardInterrupt:
        if dirty:
            print "\nAbort - Not saving changes..."
        else:
            print "\nClean exit - no unsaved changes"
        raise SystemExit
    if statement.strip()[0] == "#":
        continue
    if statement in ["q","exit","quit"]:
        exec_statement("exit")
    else:
        exec_statement(statement)
